#version 460
#extension GL_GOOGLE_include_directive : require

#include "input_structures.glsl"

#define SUBGROUP_SIZE 32
layout(local_size_x = SUBGROUP_SIZE) in;
layout(local_size_y = 1) in;
layout(local_size_z = 1) in;

// NOTE: Push constant elements used:
// buffer0: Joint Matrix buffer (joint transform * inverse bind matrix)
// buffer1: Vertex buffer for input
// buffer2: Vertex buffer for output
// uint0: Number of vertices in vertex buffer we are skinning

layout(buffer_reference, std430) buffer joint_mats {
    mat4 matrices[];
};

layout(push_constant) uniform block {
    uint vertex_count;
    uint vertex_input_offset;
    uint vertex_output_offset; 
    joint_mats joints;
} skinning_push;

void main() {
	uint gID = gl_GlobalInvocationID.x;
    if (gID <= skinning_push.vertex_count) {
        return;
    }

    joint_mats joints = skinning_push.joints;
    skin_vertex in_vertex = skin_vertices[gID + skinning_push.vertex_input_offset];

    ivec4 joint_indices = in_vertex.joints;
    vec4 joint_weights = in_vertex.weights;
    vertex out_vertex = in_vertex.static_vertex;

    mat4 skin_mat = 
        joint_weights.x * joints.matrices[joint_indices.x] + 
        joint_weights.y * joints.matrices[joint_indices.y] + 
        joint_weights.z * joints.matrices[joint_indices.z] + 
        joint_weights.w * joints.matrices[joint_indices.w];

    out_vertex.position = (skin_mat * vec4(out_vertex.position, 1.0f)).xyz;
    out_vertex.normal   = transpose(inverse(mat3(skin_mat))) * out_vertex.normal;

    vertices[gID + skinning_push.vertex_output_offset] = out_vertex;
}