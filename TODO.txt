---------------------Code TODO: List
TODO: Test image_manager, material_manager, mesh_manager
TODO: load_gltf --> import_gltf. 
TODO: Hook up scene class

GOAL: Nothing hardcoded in renderer. Engine supplies renderables, Application code supplies what to load into engine.
NOTE: Things hardcoded in engine. Goal does not mean serialization or GUI interaction

TODO: Variables, structs, functions are renamed according to new convention. (snake case is looking ugly and long)
TODO: End _state naming paradigm:
TODO: renderer_state --> renderer/RenderEngine etc...
TODO: Rename filesystem to etfile or something similar

TODO: Serialization & Specifications for the following:
TODO: Material blueprint file:
      Path to shader to load for this blueprint
      Layout of material blueprint descriptor set binding types & numbers. Sampler, uniform buffer, storage buffer
      Layout of the inside of each struct like descriptor:
      struct xxxx {
          vec4,
          vec4,
          etc...
      };
TODO: Material instance file:
      Path to material blueprint for this instance
      Texture/Image descriptors: a path to the image
      Buffer descriptors: buffer data

TODO: Mesh files: IDK for now

TODO: Scene file: Do like GLTF file layout:
Samplers, Images, Texture, Material Instances, Material Blueprints, Meshes, Nodes, Top nodes

NOTE: Before editor make sure the system fails gracefully from any and all points of failure.
      The system cannot just shutdown if a file fails to load. More information is needed.
TODO: Create separate branch for creating an editor using Immediate mode UI Nuklear

---------------------Refactor (Changes organization of the code with the same functionality(mostly))
TODO: u32 is used for index instead of size_t many times. This should be fixed
TODO: Result of vulkan commands checking done with VK_CHECK & other result checking when necessary:
TODO: Private header files to support unit tests testing opaque types internals
TODO: state->window_extent should be set before the swapchain in case the swapchain current extent is 0xFFFFFFFF. 
      Special value to say the app is in control of the size
TODO: Vulkan string library or something like that
TODO: Logger uses etstring abstractions (just wrappers for now)
TODO: When systems fail they should be able to call shutdown procedures if the failure is recoverable: Failing with grace
TODO: Make functions not all return booleans when unnecessary
TODO: Filesystem improvements (I forgot what this meant but the file interaction is not great anyway).

---------------------Implementation (Adding code to implement a feature)
TODO: Handle minimizing
TODO: Logger outputs to log file.
TODO: Way of measuring performance: FPS and/or CPU & GPU profilers

TODO: Serialization & file parsing system:
TODO: Config file for engine to load settings
TODO: Config file for renderer to load settings

---------------------Optimizations (Changes to already present code to improve it in some manner)
TODO: Manage vulkan buffer & image memory by allocating from GPU in 
    chunks and allocating whats needed from that via views and subsections
    of the buffer/image resource.
TODO: Use multiple queue families instead of just the one. For other stuff
TODO: Use the TRANSFER QUEUE to copy the data from rendering image to the swapchain image
TODO: Staging buffer improvment: For loading on the fly | Use TRANSFER QUEUE | Eventual multithreaded
TODO: vkCreateDescriptorUpdateTemplate to use update instead of stuff

GOAL: De-spaghettification of code & unit tests to make sure optimizations and features break nothing.

---------------------Eventual (Move from here to above categories)
TODO: Runtime compilation of shader for realtime updating & loading
TODO: Check if image format has VkFormatFeatureFlagBits set for what I want to use it for
TODO: VkImageViewUsageCreateInfo structure to the pNext chain, but the view usage must be a subset of the image usage.
TODO: Make Render image format configurable from engine editor.
TODO: Validate that the device is able to create the descriptor set layouts gotten from the shaders
^^^^^^vkGetDescriptorSetLayoutSupport & (VkPhysicalDeviceMaintenance3Properties + vkGetPhysicalDeviceProperties2)

TODO: Make max resolution image and render to a swapchain sized portion of it using scissor & viewport & renderArea
TODO: If we change the resolution of the render_image, at runtime, we need to update the descriptor sets that reference it with the new image view sampler etc...

TODO: Make the renderer a dynamically loaded plugin. So it can be worked on while the engine is running
TODO: Make the game code a dynamically loaded plugin.

TODO: Handle window creation without a library

TODO: Multithreading

TODO: FIFO Struct to place events into, Deferred events.
TODO: Setup event overwritting or adding based on behavior of event. When event is fired,
        it would be able to overwrite the event waiting in the event queue or
        it would be able to combine its parameters in a predefined way(func pointer??)
TODO: Events: Data struct to support insertions with ordering(priority) value

TODO: Command Line/Terminal/Bash for the system until UI is created. As well as for temporary setting selection
TODO: UI Layer & functionality 

GOAL: Ability to edit, save, load the scene from "editor" using a scene configuration file.
      This makes it so that application code does not need to hardcode the scene data and shaders.
      No need to set shader uniform binding points or anything like that from the application's & the editor's C code.

TODO: Material Experimentaion editor feature.
      User would make materials by loading shaders & linking loaded textures to binding slots.
      Ability to link this material to existing objects

TODO: Runtime check for GLSL extension support

---------------------Build system
TODO: Setup Debug & Release configurations
TODO: SPIR-V optimizer commands in cmake

--------Graphics programming--------
NOTE: Sample 2D slice of 3D texture for wierd patterns.
Like mod world position with texture limits to index into tiling 3D texture.

NOTE: Use a procedural fragment shader output (from shader toy or something) & map a mesh as a viewport to it.
NOTE: 3D texture coords to warp the viewport for neat effects
NOTE: Use post processing texture group code to styilize procedurally generated textures

--------Future Optimizations or Refactoring--------
Create a different dynamic array data structure where the array data is not hidden
from the user but does not need to be initialized. This would be for data structures to use so a create or 
initialize function is not needed when before said structure is used;

----------------------Code I am worried I might still need but is cluttering up project code 
    f32 fov_rad = glm_rad(70.f);
    f32 aspect_ratio = ((f32)state->render_extent.width/(f32)state->render_extent.height);
    f32 n = 10000.f;
    f32 f = 0.1f;

    f32 focal_length = 1.0f / tan(fov_rad * 0.5f);

    f32 x = focal_length / aspect_ratio;
    f32 y = -focal_length;
    f32 A = n / (f - n);
    f32 B = f * A;

    m4s proj = {
        .col = {
            {x,    0.0f, 0.0f,  0.0f},
            {0.0f,    y, 0.0f,  0.0f},
            {0.0f, 0.0f,    A, -1.0f},
            {0.0f, 0.0f,    B,  0.0f}
        }
    };

    // m4s test = {
    //     .raw = {
    //         {0,  1,  2,  3},
    //         {4,  5,  6,  7},
    //         {8,  9, 10, 11},
    //         {12, 13, 14, 15}
    //     }
    // };
    // ETINFO("Test: ");
    // glms_mat4_print(test, stderr);
    // ETINFO("test.raw[2][3]: %3.3lf.", test.raw[2][3]);


    // Mesh pipeline draw
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->mesh_pipeline);

    // Descriptor set creation
    VkDescriptorSet image_set = descriptor_set_allocator_growable_allocate(
        &state->frame_allocators[state->current_frame],
        state->single_image_descriptor_set_layout,
        state);
    ds_writer writer = descriptor_set_writer_create_initialize();
    descriptor_set_writer_write_image(
        &writer,
        /* Binding: */ 0,
        state->error_checkerboard_image.view,
        state->default_sampler_nearest,
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER);
    descriptor_set_writer_update_set(&writer, image_set, state);
    descriptor_set_writer_shutdown(&writer);

    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->mesh_pipeline_layout, 0, 1, &image_set, 0, 0);

    gpu_draw_push_constants push_constants = {
        .world_matrix = glms_mat4_identity(),
        .vertex_buffer = state->rectangle.vertex_buffer_address};
    vkCmdPushConstants(cmd, state->mesh_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(gpu_draw_push_constants), &push_constants);

    vkCmdBindIndexBuffer(cmd, state->rectangle.index_buffer.handle, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(cmd, 6, 1, 0, 0, 0);

    MVP calculation: 
    m4s view = glms_translate_make((v3s){.raw = {0.f, 0.f, -5.f}});

    // TODO: Figure out projection matrix mess ups & confusion
    m4s project = glms_perspective(glm_rad(70.f), ((f32)state->window_extent.width/(f32)state->window_extent.height), 10000.f, 0.1f);
    // m4s project = glms_perspective(glm_rad(70.f), ((f32)render_extent.width/(f32)render_extent.height), 10000.f, 0.1f);
    project.raw[1][1] *= -1;

    m4s vp = glms_mat4_mul(project, view);

    gpu_draw_push_constants push_constants1 = {
        .world_matrix = vp,
        .vertex_buffer = state->meshes[2].mesh_buffers.vertex_buffer_address};
    vkCmdPushConstants(cmd, state->mesh_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(gpu_draw_push_constants), &push_constants1);

    vkCmdBindIndexBuffer(cmd, state->meshes[2].mesh_buffers.index_buffer.handle, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(cmd, state->meshes[2].surfaces[0].count, 1, state->meshes[2].surfaces[0].start_index, 0, 0);

    state->meshes = load_gltf_meshes(path, state);
    if (!state->meshes) {
        ETERROR("Error loading file %s", path);
        return false;
    }

    // Get mesh count for memory allcoation
    state->backing_mesh_node_count = dynarray_length(state->meshes);
    
    // Create backing memory for the loaded node pointers to point to
    state->backing_mesh_nodes = etallocate(
        sizeof(mesh_node) * state->backing_mesh_node_count,
        MEMORY_TAG_RENDERER);

    // Create dynarray to store loaded node pointers
    state->loaded_nodes = dynarray_create(state->backing_mesh_node_count, sizeof(node*));

    for (u32 i = 0; i < state->backing_mesh_node_count; ++i) {
        mesh_asset* m = &state->meshes[i];

        // Initialize mesh node i in backing mesh node array
        mesh_node_create(&state->backing_mesh_nodes[i]);

        // pointer to initialized mesh node for convinience
        mesh_node* new_node = &state->backing_mesh_nodes[i];
        new_node->mesh = m;
        new_node->base.local_transform = glms_mat4_identity();
        new_node->base.world_transform = glms_mat4_identity();

        for (u32 j = 0; j < dynarray_length(new_node->mesh->surfaces); j++) {
            geo_surface* s = &new_node->mesh->surfaces[j];
            s->material = (GLTF_material*)&state->default_data;
        }
        // Get node reference
        node* node = node_from_mesh_node(new_node);
        dynarray_push((void**)&state->loaded_nodes, &node);
    }



static void initialize_mesh_pipeline(renderer_state* state) {
    load_shader(state, "build/assets/shaders/mesh.vert.spv", &state->mesh_vertex);
    load_shader(state, "build/assets/shaders/tex_image.frag.spv", &state->mesh_fragment);
    ETINFO("Mesh pipeline shaders loaded.");

    VkPushConstantRange buffer_range = {
        .offset = 0,
        .size = sizeof(gpu_draw_push_constants),
        .stageFlags = VK_SHADER_STAGE_VERTEX_BIT};
    
    VkPipelineLayoutCreateInfo pipeline_layout_info = init_pipeline_layout_create_info();
    pipeline_layout_info.pushConstantRangeCount = 1;
    pipeline_layout_info.pPushConstantRanges = &buffer_range;
    pipeline_layout_info.setLayoutCount = 1;
    pipeline_layout_info.pSetLayouts = &state->single_image_descriptor_set_layout;
    VK_CHECK(vkCreatePipelineLayout(
        state->device.handle,
        &pipeline_layout_info,
        state->allocator,
        &state->mesh_pipeline_layout));
    
    pipeline_builder builder = pipeline_builder_create();
    builder.layout = state->mesh_pipeline_layout;
    pipeline_builder_set_shaders(&builder, state->mesh_vertex, state->mesh_fragment);
    pipeline_builder_set_input_topology(&builder, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
    pipeline_builder_set_polygon_mode(&builder, VK_POLYGON_MODE_FILL);
    pipeline_builder_set_cull_mode(&builder, VK_CULL_MODE_NONE, VK_FRONT_FACE_CLOCKWISE);
    pipeline_builder_set_multisampling_none(&builder);
    pipeline_builder_disable_blending(&builder);
    // pipeline_builder_enable_blending_additive(&builder);
    // pipeline_builder_enable_blending_alphablend(&builder);
    pipeline_builder_enable_depthtest(&builder, true, VK_COMPARE_OP_GREATER_OR_EQUAL);
    pipeline_builder_set_color_attachment_format(&builder, state->render_image.format);
    pipeline_builder_set_depth_attachment_format(&builder, state->depth_image.format);
    state->mesh_pipeline = pipeline_builder_build(&builder, state);
    
    pipeline_builder_destroy(&builder);

    ETINFO("Mesh pipeline & pipeline layout created");
}

static void shutdown_mesh_pipeline(renderer_state* state) {
    vkDestroyPipeline(state->device.handle, state->mesh_pipeline, state->allocator);
    vkDestroyPipelineLayout(state->device.handle, state->mesh_pipeline_layout, state->allocator);
    ETINFO("Mesh pipeline & pipeline layout destroyed");

    unload_shader(state, &state->mesh_fragment);
    unload_shader(state, &state->mesh_vertex);
    ETINFO("Mesh pipeline shaders unloaded.");
}
