--------Immediate--------
TODO: Make max resolution image and render to a swapchain sized portion of it using scissor & viewport & renderArea

TODO: state->window_extent should be set before the swapchain in case the swapchain current extent is 0xFFFFFFFF. 
Special value to say the app is in control of the size

TODO: If we change the resolution of the render_image we need to update the descriptor sets that reference it with the new image view sampler etc...
TODO: Descriptor sets still reference old render image. So they need to be updated

---------------------More Immediate---------------------
TODO: Load gltf textures 

TODO: RendererAPI:
      TODO: Create default scene & load that by default are in engine settings
      TODO: Functions to expose loading & models & scenes
      TODO: Functions to expose loading shaders & making materials from them

GOAL: Nothing hardcoded in renderer. Systems supply renderables, Application code supplies what to load into systems.

--------Improvements for after rendering architecture framework is down but not optimized at all--------
TODO: Way of measuring performance: FPS and/or CPU & GPU profilers

NOTE: Renderer specific:
    TODO: Manage vulkan buffer & image memory by allocating from GPU in 
    chunks and allocating whats needed from that via views and subsections
    of the buffer/image resource.

    TODO: Result of vulkan commands checking done with VK_CHECK & other result checking when unnecessary:
    TODO: Vulkan string library or something like that

    TODO: Use multiple queue families instead of just the one. For other stuff

    TODO: SPIR-V optimizer commands in cmake
    TODO: Runtime compilation of shader for realtime updating & loading

    TODO: Check if image format has VkFormatFeatureFlagBits set for what I want to use it for
    TODO: VkImageViewUsageCreateInfo structure to the pNext chain, but the view usage must be a subset of the image usage.

    TODO: Make Render image format configurable from engine editor.

    TODO: Use the TRANSFER QUEUE to copy the data from rendering image to the swapchain image
    TODO: Validate that the device is able to create the descriptor set layouts gotten from the shaders
    ^^vkGetDescriptorSetLayoutSupport & (VkPhysicalDeviceMaintenance3Properties + vkGetPhysicalDeviceProperties2)

    TODO: Make the renderer a dynamically loaded plugin.

NOTE: Not Renderer specific:
    TODO: Handle minimizing
    
    TODO: Logger outputs to log file.

    TODO: Logger uses etstring abstractions (just wrappers for now)

    TODO: FIFO Struct to place events into
    TODO: Setup event overwritting or adding based on behavior of event. When event is fired,
          it would be able to overwrite the event waiting in the event queue or
          it would be able to combine its parameters in a predefined way(func pointer??)
    TODO: Events: Data struct to support insertions with ordering(priority) value

    TODO: Use multiple queue families instead of just the one. For other stuff

    TODO: Staging buffer improvment: For loading on the fly | Use transfer queue | Eventual multithreaded
    TODO: vkCreateDescriptorUpdateTemplate to use update instead of stuff

    TODO: Make functions not all return booleans when unnecessary
    TODO: Change from passing by pointer unless value is changing
    TODO: Filesystem typedef FILE etfile instead of struct nonsense
    TODO: Better way of doing the filesystem.

    TODO: When systems fail they should be able to call shutdown procedures if the failure is recoverable

    TODO: Make the game code a dynamically loaded plugin.

TODO: Unit tests
TODO: Setup Debug & Release configurations
GOAL: De-spaghettification of code & unit tests to make sure optimizations and features break nothing.
Rename types to more suitable things: End _state naming paradigm:
renderer_state --> renderer/RenderEngine etc...

Adopt a new naming paradigm/style guide.
Snake case for function names and camel case for type names or something.

TODO: Nuklear UI vs some sort of imgui integration

--------When rendering is at an acceptable level & RenderingAPI has been created to expose functionality--------
TODO: Serialization
    TODO: Config file for engine to load settings
    TODO: Config file for renderer to load settings

TODO: Command Line/Terminal/Bash for the system until UI is created. As well as for temporary setting selection
TODO: UI Layer & functionality 

GOAL: Ability to edit, save, load the scene from "editor" using a scene configuration file.
      This makes it so that application code does not need to hardcode the scene data and shaders.
      No need to set shader uniform binding points or anything like that from the application's & the editor's C code.

TODO: Material Experimentaion editor feature.
      User would make materials by loading shaders & linking loaded textures to binding slots.
      Ability to link this material to existing objects

TODO: Runtime check for GLSL extension support

TODO: Clang makefile creation to check for strict aliasing violation

--------Finally can do some graphics programming--------
NOTE: Sample 2D slice of 3D texture for wierd patterns.
Like mod world position with texture limits to index into tiling 3D texture.

NOTE: Use a procedural fragment shader output (from shader toy or something) & map a mesh as a viewport to it.
NOTE: 3D texture coords to warp the viewport for neat effects
NOTE: Use post processing texture group code to styilize procedurally generated textures

--------Future Optimizations or Refactoring--------
CPU profiler & GPU profiler to profile performance
Create a different dynamic array data structure where the array data is not hidden
from the user but does not need to be initialized. This would be for data structures to use so a create or 
initialize function is not needed when before said structure is used;

----------------------Code I am worried I might still need but is cluttering code 
    f32 fov_rad = glm_rad(70.f);
    f32 aspect_ratio = ((f32)state->render_extent.width/(f32)state->render_extent.height);
    f32 n = 10000.f;
    f32 f = 0.1f;

    f32 focal_length = 1.0f / tan(fov_rad * 0.5f);

    f32 x = focal_length / aspect_ratio;
    f32 y = -focal_length;
    f32 A = n / (f - n);
    f32 B = f * A;

    m4s proj = {
        .col = {
            {x,    0.0f, 0.0f,  0.0f},
            {0.0f,    y, 0.0f,  0.0f},
            {0.0f, 0.0f,    A, -1.0f},
            {0.0f, 0.0f,    B,  0.0f}
        }
    };

    // m4s test = {
    //     .raw = {
    //         {0,  1,  2,  3},
    //         {4,  5,  6,  7},
    //         {8,  9, 10, 11},
    //         {12, 13, 14, 15}
    //     }
    // };
    // ETINFO("Test: ");
    // glms_mat4_print(test, stderr);
    // ETINFO("test.raw[2][3]: %3.3lf.", test.raw[2][3]);


    // Mesh pipeline draw
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->mesh_pipeline);

    // Descriptor set creation
    VkDescriptorSet image_set = descriptor_set_allocator_growable_allocate(
        &state->frame_allocators[state->current_frame],
        state->single_image_descriptor_set_layout,
        state);
    ds_writer writer = descriptor_set_writer_create_initialize();
    descriptor_set_writer_write_image(
        &writer,
        /* Binding: */ 0,
        state->error_checkerboard_image.view,
        state->default_sampler_nearest,
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER);
    descriptor_set_writer_update_set(&writer, image_set, state);
    descriptor_set_writer_shutdown(&writer);

    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->mesh_pipeline_layout, 0, 1, &image_set, 0, 0);

    gpu_draw_push_constants push_constants = {
        .world_matrix = glms_mat4_identity(),
        .vertex_buffer = state->rectangle.vertex_buffer_address};
    vkCmdPushConstants(cmd, state->mesh_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(gpu_draw_push_constants), &push_constants);

    vkCmdBindIndexBuffer(cmd, state->rectangle.index_buffer.handle, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(cmd, 6, 1, 0, 0, 0);

    MVP calculation: 
    m4s view = glms_translate_make((v3s){.raw = {0.f, 0.f, -5.f}});

    // TODO: Figure out projection matrix mess ups & confusion
    m4s project = glms_perspective(glm_rad(70.f), ((f32)state->window_extent.width/(f32)state->window_extent.height), 10000.f, 0.1f);
    // m4s project = glms_perspective(glm_rad(70.f), ((f32)render_extent.width/(f32)render_extent.height), 10000.f, 0.1f);
    project.raw[1][1] *= -1;

    m4s vp = glms_mat4_mul(project, view);

    gpu_draw_push_constants push_constants1 = {
        .world_matrix = vp,
        .vertex_buffer = state->meshes[2].mesh_buffers.vertex_buffer_address};
    vkCmdPushConstants(cmd, state->mesh_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(gpu_draw_push_constants), &push_constants1);

    vkCmdBindIndexBuffer(cmd, state->meshes[2].mesh_buffers.index_buffer.handle, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(cmd, state->meshes[2].surfaces[0].count, 1, state->meshes[2].surfaces[0].start_index, 0, 0);

    state->meshes = load_gltf_meshes(path, state);
    if (!state->meshes) {
        ETERROR("Error loading file %s", path);
        return false;
    }

    // Get mesh count for memory allcoation
    state->backing_mesh_node_count = dynarray_length(state->meshes);
    
    // Create backing memory for the loaded node pointers to point to
    state->backing_mesh_nodes = etallocate(
        sizeof(mesh_node) * state->backing_mesh_node_count,
        MEMORY_TAG_RENDERER);

    // Create dynarray to store loaded node pointers
    state->loaded_nodes = dynarray_create(state->backing_mesh_node_count, sizeof(node*));

    for (u32 i = 0; i < state->backing_mesh_node_count; ++i) {
        mesh_asset* m = &state->meshes[i];

        // Initialize mesh node i in backing mesh node array
        mesh_node_create(&state->backing_mesh_nodes[i]);

        // pointer to initialized mesh node for convinience
        mesh_node* new_node = &state->backing_mesh_nodes[i];
        new_node->mesh = m;
        new_node->base.local_transform = glms_mat4_identity();
        new_node->base.world_transform = glms_mat4_identity();

        for (u32 j = 0; j < dynarray_length(new_node->mesh->surfaces); j++) {
            geo_surface* s = &new_node->mesh->surfaces[j];
            s->material = (GLTF_material*)&state->default_data;
        }
        // Get node reference
        node* node = node_from_mesh_node(new_node);
        dynarray_push((void**)&state->loaded_nodes, &node);
    }
