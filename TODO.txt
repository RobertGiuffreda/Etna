--------Immediate--------
TODO: Change blit to take swapchian image size & render_image size to render at whatever resolution we want
TODO: Clamp swapchain extent based on max & min values in create & resize function

TODO: VkDescriptorPool give more allocations & make one per frame or something I think
    Growable

TODO: Model Geometry Loading - DONE
TODO: Texture loading
TODO: Material set up

TODO: Texture loading management system
TODO: Materials & Material management system
TODO: Model loading management system

TODO: Renderable interface struct

TODO: Build out materials and renderable framework:

TODO: Implement scene graph rendering

TODO: RendererAPI:
    TODO: Create default scene & load that by default are in engine settings
    TODO: Refactor TODO:'s listed in vk_types.h and renderer.h
    TODO: Functions to expose loading & models & scenes
    TODO: Functions to expose loading shaders & making materials from them
    
GOAL: Nothing hardcoded in renderer. Systems supply renderables, Application code supplies what to load into systems.

--------Improvements for after rendering architecture framework is down but not optimized at all--------
NOTE: Renderer specific:
    TODO: Manage vulkan buffer & image memory by allocating from GPU in 
    chunks and allocating whats needed from that via views and subsections
    of the buffer/image resource.

    TODO: Result of vulkan commands checking done with VK_CHECK & other result checking when unnecessary:
    TODO: Vulkan string library or something like that

    TODO: Use multiple queue families instead of just the one. For other stuff

    TODO: SPIR-V optimizer commands in cmake
    TODO: Runtime compilation of shader for realtime updating & loading

    TODO: Check if image format has VkFormatFeatureFlagBits set for what I want to use it for
    TODO: VkImageViewUsageCreateInfo structure to the pNext chain, but the view usage must be a subset of the image usage.

    TODO: Make Render image format configurable from engine editor.

    TODO: Use the TRANSFER QUEUE to copy the data from rendering image to the swapchain image
    TODO: Validate that the device is able to create the descriptor set layouts gotten from the shaders
    ^^vkGetDescriptorSetLayoutSupport & (VkPhysicalDeviceMaintenance3Properties + vkGetPhysicalDeviceProperties2)

    TODO: Make the renderer a dynamically loaded plugin.

NOTE: Not Renderer specific:
    TODO: Handle minimizing
    
    TODO: Logger outputs to log file.

    TODO: FIFO Struct to place events into
    TODO: Setup event overwritting or adding based on behavior of event. When event is fired,
          it would be able to overwrite the event waiting in the event queue or
          it would be able to combine its parameters in a predefined way(func pointer??)
    TODO: Events: Data struct to support insertions with ordering(priority) value

    TODO: Use multiple queue families instead of just the one. For other stuff

    TODO: Staging buffer improvment: For loading on the fly | Use transfer queue | Eventual multithreaded
    TODO: vkCreateDescriptorUpdateTemplate to use update instead of stuff

    TODO: Make functions not all return booleans when unnecessary
    TODO: Change from passing by pointer unless value is changing
    TODO: Filesystem typedef FILE etfile instead of struct nonsense
    TODO: Better way of doing the filesystem.

    TODO: When systems fail they should be able to call shutdown procedures if the failure is recoverable

    TODO: Make the game code a dynamically loaded plugin.

TODO: Unit tests
TODO: Setup Debug & Release configurations
GOAL: De-spaghettification of code & unit tests to make sure optimizations and features break nothing.

--------When rendering is at an acceptable level & RenderingAPI has been created to expose functionality--------
TODO: Serialization
    TODO: Config file for engine to load settings
    TODO: Config file for renderer to load settings

TODO: Command Line/Terminal/Bash for the system until UI is created. As well as for temporary setting selection
TODO: UI Layer & functionality 

GOAL: Ability to edit, save, load the scene from "editor" using a scene configuration file.
      This makes it so that application code does not need to hardcode the scene data and shaders.
      No need to set shader uniform binding points or anything like that from the application's & the editor's C code.

TODO: Material Experimentaion editor feature.
      User would make materials by loading shaders & linking loaded textures to binding slots.
      Ability to link this material to existing objects

TODO: Runtime check for GLSL extension support

TODO: Clang makefile creation to check for strict aliasing violation

--------Finally can do some graphics programming--------
NOTE: Sample 2D slice of 3D texture for wierd patterns.
Like mod world position with texture limits to index into tiling 3D texture.

NOTE: Use a procedural fragment shader output (from shader toy or something) & map a mesh as a viewport to it.
NOTE: 3D texture coords to warp the viewport for neat effects
NOTE: Use post processing texture group code to styilize procedurally generated textures

--------Future Optimizations or Refactoring--------
CPU profiler & GPU profiler to profile performance
Create a different dynamic array data structure where the array data is not hidden
from the user but does not need to be initialized. This would be for data structures to use so a create or 
initialize function is not needed when before said structure is used;


------------------------------------------------------
    f32 fov_rad = glm_rad(70.f);
    f32 aspect_ratio = ((f32)state->width/(f32)state->height);
    f32 n = 10000.f;
    f32 f = 0.1f;

    f32 focal_length = 1.0f / tan(fov_rad * 0.5f);

    f32 x = focal_length / aspect_ratio;
    f32 y = -focal_length;
    f32 A = n / (f - n);
    f32 B = f * A;

    m4s proj = {
        .col = {
            {x,    0.0f, 0.0f,  0.0f},
            {0.0f,    y, 0.0f,  0.0f},
            {0.0f, 0.0f,    A, -1.0f},
            {0.0f, 0.0f,    B,  0.0f}
        }
    };

    // m4s test = {
    //     .raw = {
    //         {0,  1,  2,  3},
    //         {4,  5,  6,  7},
    //         {8,  9, 10, 11},
    //         {12, 13, 14, 15}
    //     }
    // };
    // ETINFO("Test: ");
    // glms_mat4_print(test, stderr);
    // ETINFO("test.raw[2][3]: %3.3lf.", test.raw[2][3]);


LIFE:
TODO: Research: Footbath, Juicer